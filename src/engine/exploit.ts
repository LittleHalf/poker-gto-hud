import type { GameState } from '../tools/adviser.js'
import type { GtoResult } from './gto.js'
import { estimateHandStrength, getBoardTexture, normalizePosition } from './gto.js'

export interface RawStats {
  vpip_num: number
  vpip_denom: number
  pfr_num: number
  pfr_denom: number
  af_bets: number
  af_calls: number
  cbet_fold_num: number
  cbet_fold_denom: number
  fold_to_3bet_num: number
  fold_to_3bet_denom: number
  wtsd_num: number
  wtsd_denom: number
}

export type ExploitResult = GtoResult

const LATE = ['BTN', 'CO', 'HJ']

export function getExploitAction(state: GameState, stats: RawStats | null): ExploitResult {
  // When no villain data, play aggressively by default (exploit = aggression)
  if (!stats || stats.vpip_denom < 5) {
    return getNoDataExploit(state)
  }

  const vpip      = stats.vpip_num / stats.vpip_denom
  const pfr       = stats.pfr_denom > 0 ? stats.pfr_num / stats.pfr_denom : 0.15
  const af        = stats.af_calls  > 0 ? stats.af_bets / stats.af_calls  : 1.0
  const foldTo3b  = stats.fold_to_3bet_denom > 0 ? stats.fold_to_3bet_num / stats.fold_to_3bet_denom : 0.50
  const foldToCb  = stats.cbet_fold_denom    > 0 ? stats.cbet_fold_num    / stats.cbet_fold_denom    : 0.50

  if (state.street === 'PREFLOP') {
    return getPreflopExploit({ vpip, pfr, foldTo3b, state })
  }
  return getPostflopExploit({ vpip, af, foldToCb, state })
}

// ── No data: aggressive default ───────────────────────────────────────────────

function getNoDataExploit(state: GameState): ExploitResult {
  const pos      = normalizePosition(state.hero_position)
  const isLate   = LATE.includes(pos)

  if (state.street === 'PREFLOP') {
    if (state.to_call_bb === 0) {
      const sizing = isLate ? '2.5x' : '3x'
      return { action: 'RAISE', sizing, reasoning: `Exploit: open-raise aggressively from ${pos} — no limping` }
    }
    return { action: 'RAISE', sizing: '3x', reasoning: `Exploit: 3-bet to steal with fold equity` }
  }

  const strength = estimateHandStrength(state.hero_cards, state.board)
  if (strength >= 0.60) {
    const sizing = state.to_call_bb === 0 ? '75% pot' : '3x'
    return { action: state.to_call_bb === 0 ? 'BET' : 'RAISE', sizing, reasoning: `Exploit: strong hand (${pct(strength)}) — size up, max value` }
  }
  if (state.to_call_bb === 0) {
    return { action: 'BET', sizing: '60% pot', reasoning: `Exploit: default aggression — bet when checked to, apply pressure` }
  }
  return { action: 'CALL', reasoning: `Exploit: call with unknown — gather reads, reassess next street` }
}

// ── Preflop ───────────────────────────────────────────────────────────────────

function getPreflopExploit(ctx: {
  vpip: number; pfr: number; foldTo3b: number; state: GameState
}): ExploitResult {
  const { vpip, pfr, foldTo3b, state } = ctx
  const pos      = normalizePosition(state.hero_position)
  const isLate   = LATE.includes(pos)
  const hasRaise = state.action_history.some(a => a.toLowerCase().includes('raise'))

  // Fish (wide caller, doesn't raise much) — size up for max value
  if (vpip > 0.40 && pfr < 0.12) {
    const sizing = hasRaise ? '4x' : '4x'
    return {
      action: 'RAISE', sizing,
      reasoning: `FISH (VPIP ${pct(vpip)}, PFR ${pct(pfr)}) — size up to 4x, they call too wide`,
    }
  }

  // Maniac (wide + aggressive) — 3-bet/4-bet to apply maximum pressure
  if (vpip > 0.40 && pfr > 0.30) {
    return {
      action: 'RAISE', sizing: '4x',
      reasoning: `MANIAC (VPIP ${pct(vpip)}, PFR ${pct(pfr)}) — 4-bet to neutralise aggression, they fold or stack off light`,
    }
  }

  // Nit — steal liberally, they fold to aggression
  if (vpip < 0.15) {
    return {
      action: 'RAISE', sizing: isLate ? '2.5x' : '3x',
      reasoning: `NIT (VPIP ${pct(vpip)}) — steal wide, they fold everything but premiums`,
    }
  }

  // Folds too often to 3-bets — bluff 3-bet
  if (hasRaise && foldTo3b > 0.60 && isLate) {
    return {
      action: 'RAISE', sizing: '3x',
      reasoning: `Villain folds to 3-bets ${pct(foldTo3b)} — profitable bluff 3-bet from ${pos}`,
    }
  }

  // Standard aggressive play
  return {
    action: hasRaise ? 'CALL' : 'RAISE',
    sizing: hasRaise ? undefined : '3x',
    reasoning: `Exploit default — aggressive open/call vs VPIP ${pct(vpip)}, PFR ${pct(pfr)}`,
  }
}

// ── Postflop ──────────────────────────────────────────────────────────────────

function getPostflopExploit(ctx: {
  vpip: number; af: number; foldToCb: number; state: GameState
}): ExploitResult {
  const { vpip, af, foldToCb, state } = ctx
  const strength = estimateHandStrength(state.hero_cards, state.board)
  const texture  = getBoardTexture(state.board)
  const potOdds  = state.to_call_bb > 0 ? state.to_call_bb / (state.pot_bb + state.to_call_bb) : 0
  const spr      = state.stack_bb / Math.max(state.pot_bb, 1)

  // ── Strong hand: always bet/raise, go big ────────────────────────────────
  if (strength >= 0.70) {
    const sizing = spr < 3 ? '100% pot' : '75% pot'
    if (state.to_call_bb === 0) {
      return { action: 'BET', sizing, reasoning: `Strong hand (${pct(strength)}) — exploit: size up to ${sizing}, deny equity and extract max value` }
    }
    return { action: 'RAISE', sizing: '3x', reasoning: `Strong hand (${pct(strength)}) — exploit: raise for max value, don't slow-play` }
  }

  // ── vs Passive villain (low AF): thin value bet every street ─────────────
  if (af < 0.9) {
    if (state.to_call_bb === 0 && strength >= 0.45) {
      return { action: 'BET', sizing: '60% pot', reasoning: `Passive villain (AF ${af.toFixed(2)}) — thin value bet, they call too wide and bluff too rarely` }
    }
    if (state.to_call_bb > 0 && strength > potOdds) {
      return { action: 'CALL', reasoning: `Passive villain (AF ${af.toFixed(2)}) — their bets heavily weighted to value, call with decent equity` }
    }
  }

  // ── vs Villain who folds to c-bets: fire relentlessly ────────────────────
  if (state.to_call_bb === 0 && foldToCb > 0.60) {
    return {
      action: 'BET', sizing: '75% pot',
      reasoning: `Villain folds to c-bets ${pct(foldToCb)} — fire ${texture} board at 75% pot, high fold equity`,
    }
  }

  // ── vs Aggressive villain (high AF): trap and check-call ─────────────────
  if (af > 2.0 && strength >= 0.50) {
    if (state.to_call_bb === 0) {
      return { action: 'CHECK', reasoning: `Aggressive villain (AF ${af.toFixed(2)}) — check to induce bluffs, check-raise or call down` }
    }
    return { action: 'CALL', reasoning: `Aggressive villain (AF ${af.toFixed(2)}) — call down, their aggression is wide` }
  }

  // ── Fish: value bet relentlessly with any pair+ ───────────────────────────
  if (vpip > 0.40 && af < 1.5) {
    if (state.to_call_bb === 0 && strength >= 0.40) {
      return { action: 'BET', sizing: '67% pot', reasoning: `FISH (VPIP ${pct(vpip)}) — value bet thinly, they call with any pair or draw` }
    }
    if (state.to_call_bb > 0) {
      return { action: 'CALL', reasoning: `FISH (VPIP ${pct(vpip)}) — call, they bet too wide` }
    }
  }

  // ── Default: be aggressive ───────────────────────────────────────────────
  if (state.to_call_bb === 0) {
    if (strength >= 0.35) {
      return { action: 'BET', sizing: '60% pot', reasoning: `Exploit default: apply pressure with ${pct(strength)} equity on ${texture} board` }
    }
    return { action: 'CHECK', reasoning: `Exploit check — too weak to bet profitably (${pct(strength)} equity)` }
  }

  if (strength > potOdds + 0.05) {
    return { action: 'CALL', reasoning: `Exploit call — equity ${pct(strength)} beats pot odds ${pct(potOdds)}` }
  }
  return { action: 'FOLD', reasoning: `Exploit fold — equity ${pct(strength)} below pot odds ${pct(potOdds)}` }
}

function pct(n: number): string { return `${(n * 100).toFixed(0)}%` }
